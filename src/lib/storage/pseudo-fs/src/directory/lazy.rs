// Copyright 2019 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

//! Implementation of a "lazy" pseudo directory.  See [`Lazy`] for details.

use crate::{
    common::{inherit_rights_for_clone, send_on_open_with_error},
    directory::{
        common::{check_child_connection_flags, encode_dirent, validate_and_split_path},
        connection::DirectoryConnection,
        entry::{DirectoryEntry, EntryInfo},
        watchers::{Watchers, WatchersAddError, WatchersSendError},
        DEFAULT_DIRECTORY_PROTECTION_ATTRIBUTES,
    },
};

use {
    fidl::endpoints::ServerEnd,
    fidl_fuchsia_io::{
        DirectoryObject, DirectoryRequest, NodeAttributes, NodeInfo, NodeMarker,
        DIRENT_TYPE_DIRECTORY, INO_UNKNOWN, MAX_FILENAME, MODE_TYPE_DIRECTORY, WATCH_EVENT_ADDED,
        WATCH_EVENT_DELETED, WATCH_EVENT_REMOVED, WATCH_MASK_ADDED, WATCH_MASK_DELETED,
        WATCH_MASK_REMOVED,
    },
    fuchsia_async::Channel,
    fuchsia_zircon::{
        sys::{ZX_ERR_INVALID_ARGS, ZX_ERR_NOT_SUPPORTED, ZX_OK},
        Status,
    },
    futures::{
        future::{FusedFuture, FutureExt},
        stream::{FusedStream, FuturesUnordered, StreamExt, StreamFuture},
        Stream,
    },
    std::{
        default::Default,
        future::Future,
        iter::{self, ExactSizeIterator},
        marker::{PhantomData, Unpin},
        mem::replace,
        pin::Pin,
        task::{Context, Poll},
    },
    thiserror::Error,
    void::{unreachable, Void},
};

/// Events that can be sent over the watcher notifications stream.  See `watcher_events` argument
/// documentation of the [`lazy`] constructor.
pub enum WatcherEvent {
    /// A directory itself has been removed.  Most files systems will not be able to support this
    /// event, in particular, when a pseudo directory can be attached in multiple spots in a pseudo
    /// directory tree, it is not clear when this event should be generated.  All the currently
    /// attached watchers will receive a WATCH_EVENT_DELETED event.  `name` is the name of the
    /// directory in it's parent listing.
    Deleted(String),
    /// One or more entries have been added to the directory.  All the currently attached watchers
    /// will receive a WATCH_EVENT_ADDED event.
    Added(Vec<String>),
    /// One or more entries have been removed from the directory.  All the currently attached
    /// watchers will receive a WATCH_EVENT_REMOVED event.
    Removed(Vec<String>),
}

/// Type of the errors that might be generated by sink callback provided to the `get_entry_names`
/// handler.  See [`lazy`] and [`lazy_attr`].
#[derive(Debug, Error)]
pub enum GetEntryNameSinkError {
    /// Provided name of an entry was longer than MAX_FILENAME bytes.
    #[error("Provided entry name exceeds MAX_FILENAME bytes")]
    NameTooLong,
}

// TODO When trait aliases are stabilized and we can use them (rust-lang/rust#41517).
// pub trait GetEntryNamesHandler<TraversalPosition> =
//     FnMut(
//             TraversalPosition,
//             &mut FnMut(&EntryInfo, &str) -> Result<bool, GetEntryNameSinkError>,
//         ) -> (TraversalPosition, Result<(), Status>)
//         + Send;

// TODO When trait aliases are stabilized and we can use them (rust-lang/rust#41517).
// pub trait GetEntryHandler<'entries> =
//     FnMut(&str) -> Result<Box<DirectoryEntry + 'entries>, Status> + Send;

/// Creates a lazy directory, with no watcher stream attached.  Watchers will not be able to attach
/// to this directory.  See [`lazy_with_watchers`].
///
/// See [`Lazy`] for details.
///
/// POSIX access attributes are set to [`DEFAULT_DIRECTORY_PROTECTION_ATTRIBUTES`].
pub fn lazy<'entries, TraversalPosition, GetEntryNames, GetEntry>(
    get_entry_names: GetEntryNames,
    get_entry: GetEntry,
) -> Lazy<'entries, TraversalPosition, GetEntryNames, GetEntry, TerminatedStream<WatcherEvent>>
where
    TraversalPosition: Default + Send,
    GetEntryNames: FnMut(
            TraversalPosition,
            &mut dyn FnMut(&EntryInfo, &str) -> Result<bool, GetEntryNameSinkError>,
        ) -> (TraversalPosition, Result<(), Status>)
        + Send,
    GetEntry: FnMut(&str) -> Result<Box<dyn DirectoryEntry + 'entries>, Status> + Send,
{
    lazy_attr_with_watchers(
        DEFAULT_DIRECTORY_PROTECTION_ATTRIBUTES,
        get_entry_names,
        get_entry,
        TerminatedStream::new(),
    )
}

/// Creates a lazy directory that can support watchers.
///
/// See [`Lazy`] for details.
///
/// POSIX access attributes are set to [`DEFAULT_DIRECTORY_PROTECTION_ATTRIBUTES`].
pub fn lazy_with_watchers<'entries, TraversalPosition, GetEntryNames, GetEntry, WatcherEvents>(
    get_entry_names: GetEntryNames,
    get_entry: GetEntry,
    watcher_events: WatcherEvents,
) -> Lazy<'entries, TraversalPosition, GetEntryNames, GetEntry, WatcherEvents>
where
    TraversalPosition: Default + Send,
    GetEntryNames: FnMut(
            TraversalPosition,
            &mut dyn FnMut(&EntryInfo, &str) -> Result<bool, GetEntryNameSinkError>,
        ) -> (TraversalPosition, Result<(), Status>)
        + Send,
    GetEntry: FnMut(&str) -> Result<Box<dyn DirectoryEntry + 'entries>, Status> + Send,
    WatcherEvents: Stream<Item = WatcherEvent> + FusedStream + Unpin + Send,
{
    lazy_attr_with_watchers(
        DEFAULT_DIRECTORY_PROTECTION_ATTRIBUTES,
        get_entry_names,
        get_entry,
        watcher_events,
    )
}

/// Creates a lazy directory with the specified POSIX access attributes, with no watcher stream
/// attached.  See [`lazy_attr_with_watchers`].
///
/// See [`Lazy`] for details.
///
pub fn lazy_attr<'entries, TraversalPosition, GetEntryNames, GetEntry>(
    protection_attributes: u32,
    get_entry_names: GetEntryNames,
    get_entry: GetEntry,
) -> Lazy<'entries, TraversalPosition, GetEntryNames, GetEntry, TerminatedStream<WatcherEvent>>
where
    TraversalPosition: Default + Send,
    GetEntryNames: FnMut(
            TraversalPosition,
            &mut dyn FnMut(&EntryInfo, &str) -> Result<bool, GetEntryNameSinkError>,
        ) -> (TraversalPosition, Result<(), Status>)
        + Send,
    GetEntry: FnMut(&str) -> Result<Box<dyn DirectoryEntry + 'entries>, Status> + Send,
{
    lazy_attr_with_watchers(
        protection_attributes,
        get_entry_names,
        get_entry,
        TerminatedStream::new(),
    )
}

/// Creates a lazy directory with the specified POSIX access attributes that can support watchers.
///
/// See [`Lazy`] for details.
///
pub fn lazy_attr_with_watchers<
    'entries,
    TraversalPosition,
    GetEntryNames,
    GetEntry,
    WatcherEvents,
>(
    protection_attributes: u32,
    get_entry_names: GetEntryNames,
    get_entry: GetEntry,
    watcher_events: WatcherEvents,
) -> Lazy<'entries, TraversalPosition, GetEntryNames, GetEntry, WatcherEvents>
where
    TraversalPosition: Default + Send,
    GetEntryNames: FnMut(
            TraversalPosition,
            &mut dyn FnMut(&EntryInfo, &str) -> Result<bool, GetEntryNameSinkError>,
        ) -> (TraversalPosition, Result<(), Status>)
        + Send,
    GetEntry: FnMut(&str) -> Result<Box<dyn DirectoryEntry + 'entries>, Status> + Send,
    WatcherEvents: Stream<Item = WatcherEvent> + FusedStream + Unpin + Send,
{
    Lazy {
        protection_attributes,
        get_entry_names,
        get_entry,
        live_entries: Vec::new(),
        connections: FuturesUnordered::new(),
        watcher_events,
        watchers: Watchers::new(),
    }
}

/// A stream that is initially terminated.  Used as a stub for lazy directories that have no
/// associated watcher event streams.
///
/// Note that this is different from the `stream.empty().fuse()` generated stream, as it is not
/// initially terminated - it gets terminated on the first `poll_next` call, while this one is
/// terminated even before that.
pub struct TerminatedStream<T> {
    _phantom: PhantomData<T>,
}

impl<T> TerminatedStream<T> {
    fn new() -> TerminatedStream<T> {
        TerminatedStream { _phantom: PhantomData }
    }
}

impl<T> Unpin for TerminatedStream<T> {}

impl<T> Stream for TerminatedStream<T> {
    type Item = T;

    fn poll_next(self: Pin<&mut Self>, _: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        Poll::Ready(None)
    }
}

impl<T> FusedStream for TerminatedStream<T> {
    fn is_terminated(&self) -> bool {
        true
    }
}

/// An implementation of a pseudo directory that generates nested entries only when they are
/// requested.  This could be useful when the number of entries is big and the expected use case is
/// that only a small fraction of all the entries will be interacted with at an given time.
///
/// [`lazy`], [`lazy_with_watchers`], [`lazy_attr`], and [`lazy_attr_with_watchers`] are used to
/// construct lazy directories.
///
/// A lazy directory contains two callbacks and a stream.  One callback, called `get_entry_names`,
/// which is used when a directory listing is requested.  Another callback, called `get_entry`, is
/// used to construct and actual entry when it is accessed.  A stream, called `watcher_events` is
/// used to send notifications to the currently connected watchers.
///
/// `get_entry_names` is provided with a position and a sink (in form of another callback).  The
/// position allows the caller to retrieve entry names starting at a point other then the very
/// first entry.  The sink is use to consume entry names and it may not be able to consume the
/// whole directory content at once as it is backed by a limited size buffer.  `get_entry_names` is
/// expected to return a new position that would allow the caller to continue the traversal from
/// the next entry.  See [`traversal_position::AlphabeticalTraversal`] for an example of a type
/// designed to be used as a traversal position.  `sink` will return Ok(true) if it can consume
/// more entries, and Ok(false) if it can not.  An Err() value is returned if the sink failed to
/// consume the entry specified.  When the traversal has reached the end of the listing, sink
/// should not be called at all - this is an indicator that we have reached the end.
///
/// And alternative to the current `get_entry_names` interface is to represent it as a closure
/// returning an iterator.  The iterator will return new position and the `EntryInfo`, name pair.
/// The problem with this approach is that Rust does not allow closures to return references to the
/// data they own (there is no way to express this in the type system currently).
///
/// `get_entry` is expected to construct an [`DirectoryEntry`] instance to back an individual entry
/// and return it.  This new entry is then owned by the lazy directory, which would run it as part
/// of it's own execution cycle.  When the last connection to this entry is closed, the entry
/// object will be destroyed.
///
/// Notice that currently there is no caching or sharing of entry objects.  Every new `open()`
/// request will cause new entry object to be allocated and used.  See #ZX-3631 for the caching
/// policy discussion.
///
/// NOTE I have considered using an iterator as the interface for `get_entry_names`.  So that
/// `get_entry_names` would return an iterator that would encapsulate the iteration position.  The
/// problem with the iterators is that they do not allow the value to be "put back".  There is an
/// [`iter::Peekable`], but it is not a trait - I would need to introduce a custom trait to support
/// this functionality which would partially remove the advantage of using a standard trait.
///
/// The other problem with iterators, is that they do not control the lifetime of the value they
/// return.  With the "sink", `get_entry_names` is providing a reference that need to be alive only
/// for the duration of the call of the "sink".  An iterator, if it is returning a reference, has
/// no control over the reference lifetime.  And if it is not returning a reference, then a copy
/// will happen, if the data could have been referenced, in cases when it relatively static.
///
/// The later may be partially addressed by generalizing the iterator over its return type, as done
/// in the [`watchers::Watchers::add`] in the next commit.  But this generalization will introduce
/// additional complexity.
///
/// `watcher_events` is a stream of events that when occure are forwarded to all the connected
/// watchers.  They are values of type [`WatcherEvent`].  If this stream reaches it's end
/// (`is_terminated()` becomes true) existing watchers connections will be closed and any new
/// watchers will not be able to connect to the node - they will receive a NOT_SUPPORTED error.
pub struct Lazy<'entries, TraversalPosition, GetEntryNames, GetEntry, WatcherEvents>
where
    TraversalPosition: Default + Send,
    GetEntryNames: FnMut(
            TraversalPosition,
            &mut dyn FnMut(&EntryInfo, &str) -> Result<bool, GetEntryNameSinkError>,
        ) -> (TraversalPosition, Result<(), Status>)
        + Send,
    GetEntry: FnMut(&str) -> Result<Box<dyn DirectoryEntry + 'entries>, Status> + Send,
    WatcherEvents: Stream<Item = WatcherEvent> + FusedStream + Unpin + Send,
{
    /// MODE_PROTECTION_MASK attributes returned by this directory through io.fidl:Node::GetAttr.
    /// They have no meaning for the directory operation itself, but may have consequences to the
    /// POSIX emulation layer.  This field should only have set bits in the MODE_PROTECTION_MASK
    /// part.
    protection_attributes: u32,

    /// This callback is invoked to get names of the entries inside the directory.  The first
    /// argument specifies the starting point.  The second argument is a "sink" that is supposed to
    /// be called with all entries that come after the first argument (in the order that is
    /// reasonable for this particular traversal type).
    ///
    /// The first argument needs to be updated to represent a traversal position that points to the
    /// last element provided to the sink.  This way next time the callback is called, it can
    /// continue form the last point of interruption.  Sink should be called as long as it is
    /// returning "true" or as long as there are any entries to return.  End of listing is reported
    /// by just not calling the sink at all.  For example if the directory has been empty in the
    /// first place or if the end of the list has been reached during the previous call.
    get_entry_names: GetEntryNames,

    /// This callback is invoked to get an actual directory entry object that corresponds to the
    /// specified name.  Note that this is never going to be called with ".", but otherwise might
    /// be called with names that has not been necessarily returned by the get_entry_names() callback.
    get_entry: GetEntry,

    /// Entries that have active connections to them.
    live_entries: Vec<Box<dyn DirectoryEntry + 'entries>>,

    connections: FuturesUnordered<StreamFuture<DirectoryConnection<TraversalPosition>>>,

    /// Stream of WatcherEvent objects that is used to notify watchers when something happens to
    /// the entries in the directory.  When this stream is terminated ([`is_terminated()`] is
    /// true), all the existing watcher connections will be closed and no new watcher connections
    /// will be allowed - they will receive NOT_SUPPORTED error.
    watcher_events: WatcherEvents,

    watchers: Watchers,
}

/// Return type for Lazy::handle_request().
struct HandleRequestResult {
    /// Current connection state.
    connection_state: ConnectionState,

    /// If the command may have an effect on the children we will need to make sure we execute
    /// their `poll` method after processing this command.
    may_affect_children: bool,
}

#[derive(PartialEq, Eq)]
enum ConnectionState {
    Alive,
    Closed,
}

impl<'entries, TraversalPosition, GetEntryNames, GetEntry, WatcherEvents>
    Lazy<'entries, TraversalPosition, GetEntryNames, GetEntry, WatcherEvents>
where
    TraversalPosition: Default + Send,
    GetEntryNames: FnMut(
            TraversalPosition,
            &mut dyn FnMut(&EntryInfo, &str) -> Result<bool, GetEntryNameSinkError>,
        ) -> (TraversalPosition, Result<(), Status>)
        + Send,
    GetEntry: FnMut(&str) -> Result<Box<dyn DirectoryEntry + 'entries>, Status> + Send,
    WatcherEvents: Stream<Item = WatcherEvent> + FusedStream + Unpin + Send,
{
    fn add_connection(&mut self, flags: u32, mode: u32, server_end: ServerEnd<NodeMarker>) {
        if let Some(connection) =
            DirectoryConnection::<TraversalPosition>::connect(flags, mode, server_end)
        {
            self.connections.push(connection);
        }
    }

    // TODO(fxb/37419): Remove default handling after methods landed.
    #[allow(unreachable_patterns)]
    fn handle_request(
        &mut self,
        req: DirectoryRequest,
        connection: &mut DirectoryConnection<TraversalPosition>,
    ) -> Result<HandleRequestResult, anyhow::Error> {
        let mut may_affect_children = false;

        match req {
            DirectoryRequest::Clone { flags, object, control_handle: _ } => {
                self.handle_clone(connection.flags, flags, 0, object);
            }
            DirectoryRequest::Close { responder } => {
                responder.send(ZX_OK)?;
                return Ok(HandleRequestResult {
                    connection_state: ConnectionState::Closed,
                    may_affect_children,
                });
            }
            DirectoryRequest::Describe { responder } => {
                let mut info = NodeInfo::Directory(DirectoryObject);
                responder.send(&mut info)?;
            }
            DirectoryRequest::Sync { responder } => {
                responder.send(ZX_ERR_NOT_SUPPORTED)?;
            }
            DirectoryRequest::GetAttr { responder } => {
                let mut attrs = NodeAttributes {
                    mode: MODE_TYPE_DIRECTORY | self.protection_attributes,
                    id: INO_UNKNOWN,
                    content_size: 0,
                    storage_size: 0,
                    link_count: 1,
                    creation_time: 0,
                    modification_time: 0,
                };
                responder.send(ZX_OK, &mut attrs)?;
            }
            DirectoryRequest::SetAttr { flags: _, attributes: _, responder } => {
                // According to zircon/system/fidl/fuchsia-io/io.fidl the only flag that might be
                // modified through this call is OPEN_FLAG_APPEND, and it is not supported by a
                // Lazy directory.
                responder.send(ZX_ERR_NOT_SUPPORTED)?;
            }
            DirectoryRequest::Open { flags, mode, path, object, control_handle: _ } => {
                self.handle_open(connection.flags, flags, mode, &path, object);
                // As we optimize our `Open` requests by navigating multiple path components at
                // once, we may attach a connected to a child node.
                may_affect_children = true;
            }
            DirectoryRequest::Unlink { path: _, responder } => {
                responder.send(ZX_ERR_NOT_SUPPORTED)?;
            }
            DirectoryRequest::ReadDirents { max_bytes, responder } => {
                self.handle_read_dirents(connection, max_bytes, |status, entries| {
                    responder.send(status.into_raw(), entries)
                })?;
            }
            DirectoryRequest::Rewind { responder } => {
                connection.seek = Default::default();
                responder.send(ZX_OK)?;
            }
            DirectoryRequest::GetToken { responder } => {
                responder.send(ZX_ERR_NOT_SUPPORTED, None)?;
            }
            DirectoryRequest::Rename { src: _, dst_parent_token: _, dst: _, responder } => {
                responder.send(ZX_ERR_NOT_SUPPORTED)?;
            }
            DirectoryRequest::Link { src: _, dst_parent_token: _, dst: _, responder } => {
                responder.send(ZX_ERR_NOT_SUPPORTED)?;
            }
            DirectoryRequest::Watch { mask, options, watcher, responder } => {
                if options != 0 {
                    responder.send(ZX_ERR_INVALID_ARGS)?;
                } else {
                    if self.watcher_events.is_terminated() {
                        responder.send(ZX_ERR_NOT_SUPPORTED)?;
                    } else {
                        self.handle_watch(mask, Channel::from_channel(watcher)?, |status| {
                            responder.send(status.into_raw())
                        })?;
                    }
                }
            }
            _ => {}
        }
        Ok(HandleRequestResult { connection_state: ConnectionState::Alive, may_affect_children })
    }

    fn handle_clone(
        &mut self,
        parent_flags: u32,
        flags: u32,
        mode: u32,
        server_end: ServerEnd<NodeMarker>,
    ) {
        let flags = match inherit_rights_for_clone(parent_flags, flags) {
            Ok(updated) => updated,
            Err(status) => {
                send_on_open_with_error(flags, server_end, status);
                return;
            }
        };

        self.add_connection(flags, mode, server_end);
    }

    fn handle_open(
        &mut self,
        parent_flags: u32,
        flags: u32,
        mut mode: u32,
        path: &str,
        server_end: ServerEnd<NodeMarker>,
    ) {
        if path == "/" {
            send_on_open_with_error(flags, server_end, Status::INVALID_ARGS);
            return;
        }

        if path == "." || path == "./" {
            self.handle_clone(parent_flags, flags, mode, server_end);
            return;
        }

        let (mut names, is_dir) = match validate_and_split_path(path) {
            Ok(v) => v,
            Err(status) => {
                send_on_open_with_error(flags, server_end, status);
                return;
            }
        };

        if is_dir {
            mode |= MODE_TYPE_DIRECTORY;
        }

        let flags = match check_child_connection_flags(parent_flags, flags) {
            Ok(updated) => updated,
            Err(status) => {
                send_on_open_with_error(flags, server_end, status);
                return;
            }
        };

        // It is up to the open method to handle OPEN_FLAG_DESCRIBE from this point on.
        self.open(flags, mode, &mut names, server_end);
    }

    fn handle_read_dirents<R>(
        &mut self,
        connection: &mut DirectoryConnection<TraversalPosition>,
        max_bytes: u64,
        responder: R,
    ) -> Result<(), fidl::Error>
    where
        R: FnOnce(Status, &mut dyn ExactSizeIterator<Item = u8>) -> Result<(), fidl::Error>,
    {
        let mut buf = Vec::new();
        let mut fit_one = false;
        let mut called_once = false;

        // It would be nice if there would be something like `replace` but that would transform a
        // value using a function and then will put it back in.  As TraversalPosition has to
        // implement Default we can abuse it here, but otherwise this seems a bit messy.
        let seek = replace(&mut connection.seek, Default::default());
        let (new_seek, res) = (self.get_entry_names)(seek, &mut |entry_info, name| {
            called_once = true;

            if name.len() >= MAX_FILENAME as usize {
                return Err(GetEntryNameSinkError::NameTooLong);
            }

            if !encode_dirent(&mut buf, max_bytes, entry_info, name) {
                return Ok(false);
            }

            fit_one = true;
            Ok(true)
        });
        connection.seek = new_seek;

        if let Err(status) = res {
            return responder(status, &mut buf.iter().cloned());
        }

        if !called_once {
            return responder(Status::OK, &mut iter::empty());
        }

        if !fit_one {
            return responder(Status::BUFFER_TOO_SMALL, &mut buf.iter().cloned());
        }

        return responder(Status::OK, &mut buf.iter().cloned());
    }

    fn handle_watch<R>(
        &mut self,
        mask: u32,
        watcher: Channel,
        responder: R,
    ) -> Result<(), fidl::Error>
    where
        R: FnOnce(Status) -> Result<(), fidl::Error>,
    {
        // Ideally I would want to get entry names from the `get_entry_names` callback and
        // immediately pass them on to the watcher that would pack then into messages of the
        // appropriate size and send them to the consumers.
        //
        // But as `get_entry_names` uses a callback, I can not really "unwrap" the stack when I
        // have a value provided to the "sink", I can only store it.  So we use a fixed size buffer
        // to request a number of entry names from `get_entry_names` that we then produce via an
        // iterator.

        let mut error = None;

        let mut names = {
            const CHUNK_SIZE: usize = 1024;

            let get_entry_names = &mut self.get_entry_names;
            let mut seek = Default::default();
            let mut buffer = Vec::new().into_iter();

            let error = &mut error;

            iter::from_fn(move || {
                if error.is_some() {
                    return None;
                }

                if buffer.len() == 0 {
                    let mut new_buffer = Vec::with_capacity(CHUNK_SIZE);
                    let (new_seek, res) = get_entry_names(
                        replace(&mut seek, Default::default()),
                        &mut |_entry_info, name| {
                            if name.len() >= MAX_FILENAME as usize {
                                return Err(GetEntryNameSinkError::NameTooLong);
                            }

                            if new_buffer.len() >= CHUNK_SIZE {
                                return Ok(false);
                            }

                            new_buffer.push(name.to_string());
                            return Ok(true);
                        },
                    );
                    seek = new_seek;
                    buffer = new_buffer.into_iter();

                    if let Err(status) = res {
                        *error = Some(status);
                        return None;
                    }
                }

                buffer.next()
            })
        };

        let status =
            self.watchers.add(&mut names, mask, watcher).map(|()| Status::OK).unwrap_or_else(
                |err| match err {
                    WatchersAddError::NameTooLong => panic!(
                        "All the names has been checked by the sink to be within limits.  There is \
                         a bug somewhere."
                    ),
                    WatchersAddError::FIDL(_) => Status::IO_REFUSED,
                },
            );

        if let Some(status) = error {
            return responder(status);
        }

        responder(status)
    }

    fn handle_watch_event(&mut self, event: WatcherEvent) {
        let (mask, event, names) = match event {
            WatcherEvent::Deleted(name) => (WATCH_MASK_DELETED, WATCH_EVENT_DELETED, vec![name]),
            WatcherEvent::Added(names) => (WATCH_MASK_ADDED, WATCH_EVENT_ADDED, names),
            WatcherEvent::Removed(names) => (WATCH_MASK_REMOVED, WATCH_EVENT_REMOVED, names),
        };

        match self.watchers.send_events(mask, event, || names.iter()) {
            Ok(()) => (),
            Err(WatchersSendError::NameTooLong) => {
                // As events are coming from a stream, we have no way to report any error back to
                // the sender.  So we just ignore names that are too long.
            }
        }
    }

    fn poll_connections(&mut self, cx: &mut Context<'_>) -> bool {
        // NOTE See `Simple::poll` for discussion on why we need a loop here, as well as to the
        // details on `rerun_children`.

        let mut rerun_children = false;

        loop {
            match self.connections.poll_next_unpin(cx) {
                Poll::Ready(Some((maybe_request, mut connection))) => {
                    if let Some(Ok(request)) = maybe_request {
                        match self.handle_request(request, &mut connection) {
                            Ok(HandleRequestResult { connection_state, may_affect_children }) => {
                                rerun_children |= may_affect_children;
                                if connection_state == ConnectionState::Alive {
                                    self.connections.push(connection.into_future())
                                }
                            }
                            // An error occurred while processing a request.  We will just close
                            // the connection, effectively closing the underlying channel in the
                            // destructor.
                            _ => (),
                        }
                    }
                    // Similarly to the error that occurs while handing a FIDL request, any
                    // connection level errors cause the connection to be closed.
                }
                // Even when we have no connections any more we still report Pending state, as we
                // may get more connections open in the future.  We will return Poll::Pending
                // below.  Getting any of these two values means that we have processed all the
                // items that might have been triggered current waker activation.
                Poll::Ready(None) | Poll::Pending => break,
            }
        }

        rerun_children
    }

    fn poll_watchers(&mut self, cx: &mut Context<'_>) {
        // Similarly to the poll_connections, we need to loop when dealing with a stream.
        if !self.watcher_events.is_terminated() {
            loop {
                match self.watcher_events.poll_next_unpin(cx) {
                    Poll::Ready(Some(event)) => {
                        self.handle_watch_event(event);
                    }
                    Poll::Ready(None) => {
                        self.watchers.close_all();
                        break;
                    }
                    Poll::Pending => break,
                }
            }
        }

        self.watchers.remove_dead(cx);
    }

    fn poll_live_entries(&mut self, cx: &mut Context<'_>) {
        // It would be nice if Vec would provide a method that would give mutable (or better
        // owning) access to all the elements, and would allow to drop those that are unneeded.
        // `drain_filter` does something similar, but it is unstable (rust-lang/rust#43244).
        // As we do not need to preserve the order, we can get away with `swap_remove`, but it
        // is a bit ugly.
        let mut i = 0;
        while i < self.live_entries.len() {
            let entry = &mut self.live_entries[i];

            match entry.poll_unpin(cx) {
                Poll::Pending => (),
                Poll::Ready(x) => unreachable(x),
            }

            if entry.is_terminated() {
                self.live_entries.swap_remove(i);
            } else {
                i += 1;
            }
        }
    }
}

impl<'entries, TraversalPosition, GetEntryNames, GetEntry, WatcherEvents> DirectoryEntry
    for Lazy<'entries, TraversalPosition, GetEntryNames, GetEntry, WatcherEvents>
where
    TraversalPosition: Default + Send,
    GetEntryNames: FnMut(
            TraversalPosition,
            &mut dyn FnMut(&EntryInfo, &str) -> Result<bool, GetEntryNameSinkError>,
        ) -> (TraversalPosition, Result<(), Status>)
        + Send,
    GetEntry: FnMut(&str) -> Result<Box<dyn DirectoryEntry + 'entries>, Status> + Send,
    WatcherEvents: Stream<Item = WatcherEvent> + FusedStream + Unpin + Send,
{
    fn open(
        &mut self,
        flags: u32,
        mode: u32,
        path: &mut dyn Iterator<Item = &str>,
        server_end: ServerEnd<NodeMarker>,
    ) {
        let name = match path.next() {
            Some(name) => name,
            None => {
                self.add_connection(flags, mode, server_end);
                return;
            }
        };

        let mut entry = match (self.get_entry)(name) {
            Ok(entry) => entry,
            Err(status) => {
                send_on_open_with_error(flags, server_end, status);
                return;
            }
        };

        // While this function is recursive, and Rust does not support TCO at the moment, recursion
        // here does not seem to be too bad.  I've tested a method with a very similar layout:
        //
        //     fn open(&mut self, a: u32, b: u32, path: &mut Iterator<Item = &str>, v: u64) -> Result<(), Error>;
        //
        // You can run it here:
        //
        //     https://play.rust-lang.org/?version=nightly&gist=5471f93c52f3adb7c8d6741ea96f9bce
        //
        // Given a path with 2048 components, which is the maximum possible path, considering the
        // MAX_PATH restriction of 4096, the function used 290KBs of stack.  Rust, by default, uses
        // 2MB stacks.
        //
        // Considering that the open method will only use recursion for the pseudo directories
        // created by the server, it is not very likely that the server will create such a deep
        // tree in the first place.
        //
        // Removing recursion is a bit inconvenient, as open() is the API for the tree entries.
        // One way to remove the recursion that I can think of, is to introduce a
        //
        //     open_next_entry_or_consume(flags, mode, entry_name, path, server_end) -> Option<&mut DirectoryEntry>
        //
        // method that would either return the next DirectoryEntry or will consume the path further
        // down (recursively) returning None.  This would allow traversal to happen in a fixed
        // stack space, still allowing nodes like mount points to intercept the traversal process.
        // It seems like it will complicate the API for the DirectoryEntry implementations though.

        entry.open(flags, mode, path, server_end);
        self.live_entries.push(entry);
    }

    fn entry_info(&self) -> EntryInfo {
        EntryInfo::new(INO_UNKNOWN, DIRENT_TYPE_DIRECTORY)
    }
}

impl<'entries, TraversalPosition, GetEntryNames, GetEntry, WatcherEvents> Unpin
    for Lazy<'entries, TraversalPosition, GetEntryNames, GetEntry, WatcherEvents>
where
    TraversalPosition: Default + Send,
    GetEntryNames: FnMut(
            TraversalPosition,
            &mut dyn FnMut(&EntryInfo, &str) -> Result<bool, GetEntryNameSinkError>,
        ) -> (TraversalPosition, Result<(), Status>)
        + Send,
    GetEntry: FnMut(&str) -> Result<Box<dyn DirectoryEntry + 'entries>, Status> + Send,
    WatcherEvents: Stream<Item = WatcherEvent> + FusedStream + Unpin + Send,
{
}

impl<'entries, TraversalPosition, GetEntryNames, GetEntry, WatcherEvents> Future
    for Lazy<'entries, TraversalPosition, GetEntryNames, GetEntry, WatcherEvents>
where
    TraversalPosition: Default + Send,
    GetEntryNames: FnMut(
            TraversalPosition,
            &mut dyn FnMut(&EntryInfo, &str) -> Result<bool, GetEntryNameSinkError>,
        ) -> (TraversalPosition, Result<(), Status>)
        + Send,
    GetEntry: FnMut(&str) -> Result<Box<dyn DirectoryEntry + 'entries>, Status> + Send,
    WatcherEvents: Stream<Item = WatcherEvent> + FusedStream + Unpin + Send,
{
    type Output = Void;

    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        // NOTE Ordering is important here.  See `Simple::poll` for discussion.
        loop {
            self.poll_live_entries(cx);
            self.poll_watchers(cx);

            let rerun_children = self.poll_connections(cx);
            if !rerun_children {
                break;
            }
        }

        Poll::Pending
    }
}

impl<'entries, TraversalPosition, GetEntryNames, GetEntry, WatcherEvents> FusedFuture
    for Lazy<'entries, TraversalPosition, GetEntryNames, GetEntry, WatcherEvents>
where
    TraversalPosition: Default + Send,
    GetEntryNames: FnMut(
            TraversalPosition,
            &mut dyn FnMut(&EntryInfo, &str) -> Result<bool, GetEntryNameSinkError>,
        ) -> (TraversalPosition, Result<(), Status>)
        + Send,
    GetEntry: FnMut(&str) -> Result<Box<dyn DirectoryEntry + 'entries>, Status> + Send,
    WatcherEvents: Stream<Item = WatcherEvent> + FusedStream + Unpin + Send,
{
    fn is_terminated(&self) -> bool {
        // We have already checked is_terminated() value in `Future::poll` above.  My assumption is
        // that as the only way for the contained objects to change their state is through the
        // `poll` call, they should not change their `is_terminated` value either.  But if they do,
        // the only change can be from "false" to "true", and then the object will be destroyed
        // during the next `poll` call above (thought it seems to be a broken case from the entry
        // implementer side).
        if !self.live_entries.is_empty() {
            return false;
        }

        // If we have any watcher connections, we may still make progress when a watcher connection
        // is closed.
        if self.watchers.has_connections() {
            return false;
        }

        self.connections.is_terminated()
    }
}

#[cfg(test)]
mod tests {
    use super::{lazy, lazy_attr, lazy_with_watchers, GetEntryNameSinkError, WatcherEvent};

    use {
        crate::directory::{
            entry::{DirectoryEntry, EntryInfo},
            test_utils::{run_server_client, DirentsSameInodeBuilder},
            traversal_position::AlphabeticalTraversal,
        },
        crate::file::simple::{read_only, read_only_static},
        fidl_fuchsia_io::{
            NodeAttributes, DIRENT_TYPE_DIRECTORY, DIRENT_TYPE_FILE, INO_UNKNOWN,
            MODE_TYPE_DIRECTORY, OPEN_FLAG_DESCRIBE, OPEN_RIGHT_READABLE, WATCH_MASK_ADDED,
            WATCH_MASK_EXISTING, WATCH_MASK_IDLE, WATCH_MASK_REMOVED,
        },
        fuchsia_zircon::{MessageBuf, Status},
        futures::{channel::mpsc, SinkExt},
        libc::{S_IRGRP, S_IROTH, S_IRUSR, S_IXGRP, S_IXOTH, S_IXUSR},
        proc_macro_hack::proc_macro_hack,
    };

    // Crate level import of this macro does not affect nested modules.  And as attributes can only
    // be applied to the whole "use" directive, this need to be present here and need to be
    // separate form the above.  "use crate::pseudo_directory" generates a warning referring to
    // "issue #52234 <https://github.com/rust-lang/rust/issues/52234>".
    #[proc_macro_hack(support_nested)]
    use fuchsia_vfs_pseudo_fs_macros::pseudo_directory;

    /// A helper to generate `get_entry_names` callbacks for the lazy directories.  This helper
    /// generates callbacks that return the same content every time and the entries are
    /// alphabetically sorted (the later is convenient when traversal position need to be
    /// remembered).
    // I wish I would be able to move an impl type declaration into a where clause, but that would
    // require me to add generic arguments to build_sorted_static_get_entry_names() and that breaks
    // inference, as the return type is not specific enough.
    //
    // In other words, I would better write this function as
    //
    //     build_sorted_static_get_entry_names<Res>(...) -> impl Res
    //     where
    //         Res: FnMut(...) -> (...)
    //
    // but if I do that, then the caller can specify what `Res` is and that is wrong.  I think
    // trait aliases should help here as soon as they are stabilized (rust-lang/rust#41517).
    fn build_sorted_static_get_entry_names(
        mut entries: Vec<(u8, &'static str)>,
    ) -> impl FnMut(
        AlphabeticalTraversal,
        &mut dyn FnMut(&EntryInfo, &str) -> Result<bool, GetEntryNameSinkError>,
    ) -> (AlphabeticalTraversal, Result<(), Status>) {
        use AlphabeticalTraversal::{Dot, End, Name, Start};

        entries.sort_unstable_by_key(|&(_, name)| name);

        let entries = {
            let mut res = vec![(Dot, EntryInfo::new(INO_UNKNOWN, DIRENT_TYPE_DIRECTORY))];
            res.extend(entries.into_iter().map(|(dirent_type, name)| {
                (Name(name.to_string()), EntryInfo::new(INO_UNKNOWN, dirent_type))
            }));
            res
        };

        let dot_entry_info = EntryInfo::new(INO_UNKNOWN, DIRENT_TYPE_DIRECTORY);

        move |p, sink: &mut dyn FnMut(&EntryInfo, &str) -> Result<bool, GetEntryNameSinkError>| {
            let mut i = match entries.binary_search_by(|(candidate_pos, _)| candidate_pos.cmp(&p)) {
                Ok(i) => i + 1,
                Err(i) => i,
            };

            let mut last_retruned = p;

            while i < entries.len() {
                let (pos, entry_info) = &entries[i];
                let sink_res = sink(
                    match &pos {
                        Start => panic!("`entries` does not contain Start"),
                        Dot => &dot_entry_info,
                        Name(_) => &entry_info,
                        End => panic!("`entries` does not contain End"),
                    },
                    match &pos {
                        Start => panic!("`entries` does not contain Start"),
                        Dot => ".",
                        Name(name) => name.as_str(),
                        End => panic!("`entries` does not contain End"),
                    },
                );
                match sink_res {
                    Ok(true) => i += 1,
                    Ok(false) => return (last_retruned, Ok(())),
                    Err(GetEntryNameSinkError::NameTooLong) => {
                        panic!("sink returned NameTooLong for '{:?}'", entries[i])
                    }
                }
                last_retruned = pos.clone();
            }

            return (End, Ok(()));
        }
    }

    #[test]
    fn empty_lazy() {
        run_server_client(
            OPEN_RIGHT_READABLE,
            lazy(|_p, _sink| (AlphabeticalTraversal::End, Ok(())), |_name| Err(Status::NOT_FOUND)),
            |root| async move {
                assert_close!(root);
            },
        );
    }

    #[test]
    fn empty_lazy_get_attr() {
        run_server_client(
            OPEN_RIGHT_READABLE,
            lazy(|_p, _sink| (AlphabeticalTraversal::End, Ok(())), |_name| Err(Status::NOT_FOUND)),
            |root| async move {
                assert_get_attr!(
                    root,
                    NodeAttributes {
                        mode: MODE_TYPE_DIRECTORY | S_IRUSR,
                        id: INO_UNKNOWN,
                        content_size: 0,
                        storage_size: 0,
                        link_count: 1,
                        creation_time: 0,
                        modification_time: 0,
                    }
                );
                assert_close!(root);
            },
        );
    }

    #[test]
    fn lazy_attr_directory_get_attr() {
        run_server_client(
            OPEN_RIGHT_READABLE,
            lazy_attr(
                S_IXOTH | S_IROTH | S_IXGRP | S_IRGRP | S_IXUSR | S_IRUSR,
                |_p, _sink| (AlphabeticalTraversal::End, Ok(())),
                |_name| Err(Status::NOT_FOUND),
            ),
            |root| async move {
                assert_get_attr!(
                    root,
                    NodeAttributes {
                        mode: MODE_TYPE_DIRECTORY
                            | (S_IXOTH | S_IROTH | S_IXGRP | S_IRGRP | S_IXUSR | S_IRUSR),
                        id: INO_UNKNOWN,
                        content_size: 0,
                        storage_size: 0,
                        link_count: 1,
                        creation_time: 0,
                        modification_time: 0,
                    }
                );
                assert_close!(root);
            },
        );
    }

    #[test]
    fn static_listing() {
        let get_entry_names = build_sorted_static_get_entry_names(vec![
            (DIRENT_TYPE_FILE, "one"),
            (DIRENT_TYPE_FILE, "two"),
            (DIRENT_TYPE_FILE, "three"),
        ]);

        run_server_client(
            OPEN_RIGHT_READABLE,
            lazy(get_entry_names, |_name| Err(Status::NOT_FOUND)),
            |root| {
                async move {
                    {
                        let mut expected = DirentsSameInodeBuilder::new(INO_UNKNOWN);
                        // Note that the build_sorted_static_get_entry_names() will sort entries
                        // alphabetically when returning them, so we see a different order here.
                        expected
                            .add(DIRENT_TYPE_DIRECTORY, b".")
                            .add(DIRENT_TYPE_FILE, b"one")
                            .add(DIRENT_TYPE_FILE, b"three")
                            .add(DIRENT_TYPE_FILE, b"two");

                        assert_read_dirents!(root, 1000, expected.into_vec());
                    }

                    assert_close!(root);
                }
            },
        );
    }

    #[test]
    fn static_entries() {
        let get_entry_names = build_sorted_static_get_entry_names(vec![
            (DIRENT_TYPE_FILE, "one"),
            (DIRENT_TYPE_FILE, "two"),
            (DIRENT_TYPE_FILE, "three"),
        ]);

        // Explicit type here is necessary, as rustc seems to be missing the point that
        // `PseudoFile` returned by the `read_only` call implements `DirectoryEntry`.  Yet with an
        // explicit type everything works.  It would be nice to understand why is this happening.
        let get_entry: &mut (dyn FnMut(&str) -> Result<Box<dyn DirectoryEntry>, Status> + Send) =
            &mut |name: &str| {
                let name = name.to_string();
                Ok(Box::new(read_only(move || {
                    let content = format!("File {} content", name);
                    Ok(content.into_bytes())
                })))
            };

        run_server_client(
            OPEN_RIGHT_READABLE,
            lazy(get_entry_names, get_entry),
            |root| async move {
                let flags = OPEN_RIGHT_READABLE | OPEN_FLAG_DESCRIBE;
                open_as_file_assert_content!(&root, flags, "one", "File one content");
                open_as_file_assert_content!(&root, flags, "two", "File two content");
                open_as_file_assert_content!(&root, flags, "three", "File three content");

                assert_close!(root);
            },
        );
    }

    #[test]
    fn static_entries_with_traversal() {
        let get_entry_names = build_sorted_static_get_entry_names(vec![
            (DIRENT_TYPE_DIRECTORY, "etc"),
            (DIRENT_TYPE_FILE, "files"),
        ]);

        // Explicit type here is necessary, as rustc seems to be missing the point that
        // `PseudoFile` returned by the `read_only` call implements `DirectoryEntry`.  Yet with an
        // explicit type everything works.  It would be nice to understand why is this happening.
        let get_entry: &mut (dyn FnMut(&str) -> Result<Box<dyn DirectoryEntry>, Status> + Send) =
            &mut |name: &str| match name {
                "etc" => Ok(Box::new(pseudo_directory! {
                    "fstab" => read_only_static("/dev/fs /"),
                    "ssh" => pseudo_directory! {
                        "sshd_config" => read_only_static("# Empty"),
                    },
                })),
                "files" => Ok(Box::new(read_only_static("Content"))),
                _ => Err(Status::NOT_FOUND),
            };

        run_server_client(
            OPEN_RIGHT_READABLE,
            lazy(get_entry_names, get_entry),
            |root| async move {
                let flags = OPEN_RIGHT_READABLE | OPEN_FLAG_DESCRIBE;
                {
                    let mut expected = DirentsSameInodeBuilder::new(INO_UNKNOWN);
                    expected
                        .add(DIRENT_TYPE_DIRECTORY, b".")
                        .add(DIRENT_TYPE_DIRECTORY, b"etc")
                        .add(DIRENT_TYPE_FILE, b"files");

                    assert_read_dirents!(root, 1000, expected.into_vec());
                }

                {
                    let etc_dir = open_get_directory_proxy_assert_ok!(&root, flags, "etc");

                    let mut expected = DirentsSameInodeBuilder::new(INO_UNKNOWN);
                    expected
                        .add(DIRENT_TYPE_DIRECTORY, b".")
                        .add(DIRENT_TYPE_FILE, b"fstab")
                        .add(DIRENT_TYPE_DIRECTORY, b"ssh");

                    assert_read_dirents!(etc_dir, 1000, expected.into_vec());
                    assert_close!(etc_dir);
                }

                {
                    let ssh_dir = open_get_directory_proxy_assert_ok!(&root, flags, "etc/ssh");

                    let mut expected = DirentsSameInodeBuilder::new(INO_UNKNOWN);
                    expected.add(DIRENT_TYPE_DIRECTORY, b".").add(DIRENT_TYPE_FILE, b"sshd_config");

                    assert_read_dirents!(ssh_dir, 1000, expected.into_vec());
                    assert_close!(ssh_dir);
                }

                open_as_file_assert_content!(&root, flags, "etc/fstab", "/dev/fs /");
                open_as_file_assert_content!(&root, flags, "files", "Content");

                assert_close!(root);
            },
        );
    }

    #[test]
    fn dynamic_listing() {
        let mut listing1 = build_sorted_static_get_entry_names(vec![
            (DIRENT_TYPE_FILE, "one"),
            (DIRENT_TYPE_FILE, "two"),
        ]);
        let mut listing2 = build_sorted_static_get_entry_names(vec![
            (DIRENT_TYPE_FILE, "two"),
            (DIRENT_TYPE_FILE, "three"),
        ]);

        let get_entry_names = {
            enum Stage {
                One,
                Two,
            };
            let mut stage = Stage::One;
            move |p, sink: &mut dyn FnMut(&EntryInfo, &str) -> Result<bool, GetEntryNameSinkError>| {
                match stage {
                    Stage::One => {
                        let (p, res) = listing1(p, sink);
                        if p == AlphabeticalTraversal::End {
                            stage = Stage::Two;
                        }
                        (p, res)
                    }
                    Stage::Two => listing2(p, sink),
                }
            }
        };

        run_server_client(
            OPEN_RIGHT_READABLE,
            lazy(get_entry_names, |_name| Err(Status::NOT_FOUND)),
            |root| {
                async move {
                    {
                        let mut expected = DirentsSameInodeBuilder::new(INO_UNKNOWN);
                        // Note that the build_sorted_static_get_entry_names() will sort entries
                        // alphabetically when returning them, so we see a different order here.
                        expected
                            .add(DIRENT_TYPE_DIRECTORY, b".")
                            .add(DIRENT_TYPE_FILE, b"one")
                            .add(DIRENT_TYPE_FILE, b"two");

                        assert_read_dirents!(root, 1000, expected.into_vec());
                    }

                    assert_rewind!(root);

                    {
                        let mut expected = DirentsSameInodeBuilder::new(INO_UNKNOWN);
                        // Note that the build_sorted_static_get_entry_names() will sort entries
                        // alphabetically when returning them, so we see a different order here.
                        expected
                            .add(DIRENT_TYPE_DIRECTORY, b".")
                            .add(DIRENT_TYPE_FILE, b"three")
                            .add(DIRENT_TYPE_FILE, b"two");

                        assert_read_dirents!(root, 1000, expected.into_vec());
                    }

                    assert_close!(root);
                }
            },
        );
    }

    #[test]
    fn dynamic_entries() {
        let get_entry_names = build_sorted_static_get_entry_names(vec![
            (DIRENT_TYPE_FILE, "file1"),
            (DIRENT_TYPE_FILE, "file2"),
        ]);

        // Explicit type here is necessary, as rustc seems to be missing the point that
        // `PseudoFile` returned by the `read_only` call implements `DirectoryEntry`.  Yet with an
        // explicit type everything works.  It would be nice to understand why is this happening.
        let get_entry: &mut (dyn FnMut(&str) -> Result<Box<dyn DirectoryEntry>, Status> + Send) = {
            let mut count = 0;

            &mut move |name: &str| match name {
                "file1" => {
                    count += 1;
                    Ok(Box::new(read_only(move || {
                        let content = format!("Content: {}", count);
                        Ok(content.into_bytes())
                    })))
                }
                "file2" => {
                    count += 10;
                    Ok(Box::new(read_only(move || {
                        let content = format!("Content: {}", count);
                        Ok(content.into_bytes())
                    })))
                }
                _ => Err(Status::NOT_FOUND),
            }
        };

        run_server_client(
            OPEN_RIGHT_READABLE,
            lazy(get_entry_names, get_entry),
            |root| async move {
                let flags = OPEN_RIGHT_READABLE | OPEN_FLAG_DESCRIBE;

                open_as_file_assert_content!(&root, flags, "file1", "Content: 1");
                open_as_file_assert_content!(&root, flags, "file1", "Content: 2");
                open_as_file_assert_content!(&root, flags, "file2", "Content: 12");
                open_as_file_assert_content!(&root, flags, "file2", "Content: 22");
                open_as_file_assert_content!(&root, flags, "file1", "Content: 23");

                assert_close!(root);
            },
        );
    }

    #[test]
    fn read_dirents_small_buffer() {
        let get_entry_names = build_sorted_static_get_entry_names(vec![
            (DIRENT_TYPE_DIRECTORY, "etc"),
            (DIRENT_TYPE_FILE, "files"),
            (DIRENT_TYPE_FILE, "more"),
            (DIRENT_TYPE_FILE, "uname"),
        ]);

        run_server_client(
            OPEN_RIGHT_READABLE,
            lazy(get_entry_names, |_name| Err(Status::NOT_FOUND)),
            |root| {
                async move {
                    {
                        let mut expected = DirentsSameInodeBuilder::new(INO_UNKNOWN);
                        // Entry header is 10 bytes + length of the name in bytes.
                        // (10 + 1) = 11
                        expected.add(DIRENT_TYPE_DIRECTORY, b".");
                        assert_read_dirents!(root, 11, expected.into_vec());
                    }

                    {
                        let mut expected = DirentsSameInodeBuilder::new(INO_UNKNOWN);
                        expected
                            // (10 + 3) = 13
                            .add(DIRENT_TYPE_DIRECTORY, b"etc")
                            // 13 + (10 + 5) = 28
                            .add(DIRENT_TYPE_FILE, b"files");
                        assert_read_dirents!(root, 28, expected.into_vec());
                    }

                    {
                        let mut expected = DirentsSameInodeBuilder::new(INO_UNKNOWN);
                        expected.add(DIRENT_TYPE_FILE, b"more").add(DIRENT_TYPE_FILE, b"uname");
                        assert_read_dirents!(root, 100, expected.into_vec());
                    }

                    assert_read_dirents!(root, 100, vec![]);

                    assert_close!(root);
                }
            },
        );
    }

    #[test]
    fn read_dirents_very_small_buffer() {
        let get_entry_names = build_sorted_static_get_entry_names(vec![(DIRENT_TYPE_FILE, "file")]);

        run_server_client(
            OPEN_RIGHT_READABLE,
            lazy(get_entry_names, |_name| Err(Status::NOT_FOUND)),
            |root| {
                async move {
                    // Entry header is 10 bytes, so this read should not be able to return a single entry.
                    assert_read_dirents_err!(root, 8, Status::BUFFER_TOO_SMALL);

                    {
                        let mut expected = DirentsSameInodeBuilder::new(INO_UNKNOWN);
                        expected.add(DIRENT_TYPE_DIRECTORY, b".").add(DIRENT_TYPE_FILE, b"file");
                        assert_read_dirents!(root, 100, expected.into_vec());
                    }

                    assert_close!(root);
                }
            },
        );
    }

    #[test]
    fn watch_empty() {
        let (_watcher_sender, watcher_stream) = mpsc::unbounded::<WatcherEvent>();
        let root = lazy_with_watchers(
            |_p, _sink| (AlphabeticalTraversal::End, Ok(())),
            |_name| Err(Status::NOT_FOUND),
            watcher_stream,
        );
        run_server_client(OPEN_RIGHT_READABLE, root, |root| async move {
            let mask =
                WATCH_MASK_EXISTING | WATCH_MASK_IDLE | WATCH_MASK_ADDED | WATCH_MASK_REMOVED;
            let watcher_client = assert_watch!(root, mask);

            assert_watcher_one_message_watched_events!(watcher_client, { IDLE, vec![] });

            drop(watcher_client);
            assert_close!(root);
        });
    }

    #[test]
    fn watch_non_empty() {
        let get_entry_names = build_sorted_static_get_entry_names(vec![
            (DIRENT_TYPE_FILE, "one"),
            (DIRENT_TYPE_FILE, "two"),
            (DIRENT_TYPE_FILE, "three"),
        ]);
        let (_watcher_sender, watcher_stream) = mpsc::unbounded::<WatcherEvent>();
        let root =
            lazy_with_watchers(get_entry_names, |_name| Err(Status::NOT_FOUND), watcher_stream);

        run_server_client(OPEN_RIGHT_READABLE, root, |root| async move {
            let mask =
                WATCH_MASK_EXISTING | WATCH_MASK_IDLE | WATCH_MASK_ADDED | WATCH_MASK_REMOVED;
            let watcher_client = assert_watch!(root, mask);

            assert_watcher_one_message_watched_events!(
                watcher_client,
                { EXISTING, "." },
                { EXISTING, "one" },
                { EXISTING, "three" },
                { EXISTING, "two" },
            );
            assert_watcher_one_message_watched_events!(watcher_client, { IDLE, vec![] });

            drop(watcher_client);
            assert_close!(root);
        });
    }

    #[test]
    fn watch_two_watchers() {
        let get_entry_names = build_sorted_static_get_entry_names(vec![
            (DIRENT_TYPE_FILE, "one"),
            (DIRENT_TYPE_FILE, "two"),
            (DIRENT_TYPE_FILE, "three"),
        ]);
        let (_watcher_sender, watcher_stream) = mpsc::unbounded::<WatcherEvent>();
        let root =
            lazy_with_watchers(get_entry_names, |_name| Err(Status::NOT_FOUND), watcher_stream);

        run_server_client(OPEN_RIGHT_READABLE, root, |root| async move {
            let mask =
                WATCH_MASK_EXISTING | WATCH_MASK_IDLE | WATCH_MASK_ADDED | WATCH_MASK_REMOVED;
            let watcher1_client = assert_watch!(root, mask);

            assert_watcher_one_message_watched_events!(
                watcher1_client,
                { EXISTING, "." },
                { EXISTING, "one" },
                { EXISTING, "three" },
                { EXISTING, "two" },
            );
            assert_watcher_one_message_watched_events!(watcher1_client, { IDLE, vec![] });

            let watcher2_client = assert_watch!(root, mask);

            assert_watcher_one_message_watched_events!(
                watcher2_client,
                { EXISTING, "." },
                { EXISTING, "one" },
                { EXISTING, "three" },
                { EXISTING, "two" },
            );
            assert_watcher_one_message_watched_events!(watcher2_client, { IDLE, vec![] });

            drop(watcher1_client);
            drop(watcher2_client);
            assert_close!(root);
        });
    }

    #[test]
    fn watch_with_mask() {
        let get_entry_names = build_sorted_static_get_entry_names(vec![
            (DIRENT_TYPE_FILE, "one"),
            (DIRENT_TYPE_FILE, "two"),
            (DIRENT_TYPE_FILE, "three"),
        ]);
        let (_watcher_sender, watcher_stream) = mpsc::unbounded::<WatcherEvent>();
        let root =
            lazy_with_watchers(get_entry_names, |_name| Err(Status::NOT_FOUND), watcher_stream);

        run_server_client(OPEN_RIGHT_READABLE, root, |root| async move {
            let mask = WATCH_MASK_IDLE | WATCH_MASK_ADDED | WATCH_MASK_REMOVED;
            let watcher_client = assert_watch!(root, mask);

            assert_watcher_one_message_watched_events!(watcher_client, { IDLE, vec![] });

            drop(watcher_client);
            assert_close!(root);
        });
    }

    #[test]
    fn watch_addition() {
        let get_entry_names = build_sorted_static_get_entry_names(vec![(DIRENT_TYPE_FILE, "one")]);

        let (mut watcher_sender, watcher_stream) = mpsc::unbounded::<WatcherEvent>();

        let root =
            lazy_with_watchers(get_entry_names, |_name| Err(Status::NOT_FOUND), watcher_stream);

        run_server_client(OPEN_RIGHT_READABLE, root, |root| async move {
            let mask = WATCH_MASK_ADDED | WATCH_MASK_REMOVED;
            let watcher_client = assert_watch!(root, mask);

            watcher_sender
                .send(WatcherEvent::Added(vec!["two".to_string()]))
                .await
                .expect("watcher_sender.send() failed");

            assert_watcher_one_message_watched_events!(watcher_client, { ADDED, "two" });

            watcher_sender
                .send(WatcherEvent::Added(vec!["three".to_string(), "four".to_string()]))
                .await
                .expect("watcher_sender.send() failed");

            assert_watcher_one_message_watched_events!(
                watcher_client,
                { ADDED, "three" },
                { ADDED, "four" },
            );

            assert_close!(root);
        });
    }

    #[test]
    fn watch_removal() {
        let get_entry_names = build_sorted_static_get_entry_names(vec![
            (DIRENT_TYPE_FILE, "one"),
            (DIRENT_TYPE_FILE, "two"),
            (DIRENT_TYPE_FILE, "three"),
            (DIRENT_TYPE_FILE, "four"),
        ]);

        let (mut watcher_sender, watcher_stream) = mpsc::unbounded::<WatcherEvent>();

        let root =
            lazy_with_watchers(get_entry_names, |_name| Err(Status::NOT_FOUND), watcher_stream);

        run_server_client(OPEN_RIGHT_READABLE, root, |root| async move {
            let mask = WATCH_MASK_ADDED | WATCH_MASK_REMOVED;
            let watcher_client = assert_watch!(root, mask);

            watcher_sender
                .send(WatcherEvent::Removed(vec!["two".to_string()]))
                .await
                .expect("watcher_sender.send() failed");

            assert_watcher_one_message_watched_events!(watcher_client, { REMOVED, "two" });

            watcher_sender
                .send(WatcherEvent::Removed(vec!["three".to_string(), "four".to_string()]))
                .await
                .expect("watcher_sender.send() failed");

            assert_watcher_one_message_watched_events!(
                watcher_client,
                { REMOVED, "three" },
                { REMOVED, "four" },
            );

            assert_close!(root);
        });
    }

    #[test]
    fn watch_watcher_stream_closed() {
        let get_entry_names = build_sorted_static_get_entry_names(vec![
            (DIRENT_TYPE_FILE, "one"),
            (DIRENT_TYPE_FILE, "two"),
            (DIRENT_TYPE_FILE, "three"),
        ]);
        // Dropping the sender will close the receiver end.
        let (_, watcher_stream) = mpsc::unbounded::<WatcherEvent>();
        let root =
            lazy_with_watchers(get_entry_names, |_name| Err(Status::NOT_FOUND), watcher_stream);

        run_server_client(OPEN_RIGHT_READABLE, root, |root| async move {
            let mask = WATCH_MASK_EXISTING | WATCH_MASK_IDLE;
            assert_watch_err!(root, mask, Status::NOT_SUPPORTED);

            assert_close!(root);
        });
    }

    #[test]
    fn watch_close_watcher_stream() {
        let get_entry_names = build_sorted_static_get_entry_names(vec![
            (DIRENT_TYPE_FILE, "one"),
            (DIRENT_TYPE_FILE, "two"),
            (DIRENT_TYPE_FILE, "three"),
        ]);
        let (mut watcher_sender, watcher_stream) = mpsc::unbounded::<WatcherEvent>();

        let root =
            lazy_with_watchers(get_entry_names, |_name| Err(Status::NOT_FOUND), watcher_stream);

        run_server_client(OPEN_RIGHT_READABLE, root, |root| {
            async move {
                let mask = WATCH_MASK_ADDED | WATCH_MASK_REMOVED;
                let watcher_client = assert_watch!(root, mask);

                watcher_sender
                    .send(WatcherEvent::Added(vec!["four".to_string()]))
                    .await
                    .expect("watcher_sender.send() failed");

                assert_watcher_one_message_watched_events!(watcher_client, { ADDED, "four" });

                watcher_sender.close_channel();

                // We can not just check the watcher channel for been closed, as it takes some number
                // of operations before all the async stuff will happen.  So, instead, we try to read
                // it and we should get a PEER_CLOSED error.
                {
                    let mut buf = MessageBuf::new();
                    let status = watcher_client
                        .recv_msg(&mut buf)
                        .await
                        .expect_err("Stream should have been closed");
                    assert_eq!(status, Status::PEER_CLOSED);
                }

                assert_close!(root);
            }
        });
    }
}
